{"id":2289,"date":"2020-06-20T11:38:11","date_gmt":"2020-06-20T06:08:11","guid":{"rendered":"https:\/\/golangbyexamples.com\/?p=2289"},"modified":"2020-11-26T01:01:37","modified_gmt":"2020-11-25T19:31:37","slug":"method-in-golang","status":"publish","type":"post","link":"https:\/\/golangbyexamples.com\/method-in-golang\/","title":{"rendered":"Method in Go (Golang)"},"content":{"rendered":"\n<p class=\"has-medium-font-size\">This is the\u00a0 chapter 20 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013\u00a0<a href=\"https:\/\/golangbyexamples.com\/golang-comprehensive-tutorial\/\">Golang Comprehensive Tutorial Series<\/a><\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Next Tutorial<\/strong>\u00a0\u2013\u00a0<a href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/\">Interface<\/a><br><strong>Previous Tutorial<\/strong>\u00a0\u2013 <a href=\"https:\/\/golangbyexamples.com\/maps-in-golang\">Maps<\/a><\/p>\n\n\n\n<p class=\"has-medium-font-size\">Now let\u2019s check out the current tutorial. Below is the table of contents for current tutorial.<\/p>\n\n\n\n<div id=\"ez-toc-container\" class=\"ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-light-blue\">\n<div class=\"ez-toc-title-container\">\n<p class=\"ez-toc-title\">Table of Contents<\/p>\n<span class=\"ez-toc-title-toggle\"><a class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"><i class=\"ez-toc-glyphicon ez-toc-icon-toggle\"><\/i><\/a><\/span><\/div>\n<nav><ul class=\"ez-toc-list ez-toc-list-level-1\"><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-1\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Overview\" title=\"Overview\">Overview<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-2\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Why_Method\" title=\"Why Method\">Why Method<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-3\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Format_of_a_Method\" title=\"Format of a Method\">Format of a Method<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-4\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Methods_on_Structs\" title=\"Methods on Structs\">Methods on Structs<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-5\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Method_on_a_Pointer_Receiver\" title=\"Method on a Pointer Receiver\">Method on a Pointer Receiver<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-6\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#When_to_use_pointer_receiver\" title=\"When to use pointer receiver\">When to use pointer receiver<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-7\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Some_More_Points_to_note_about_methods\" title=\"Some More Points to note about methods\">Some More Points to note about methods<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-8\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Methods_on_Anonymous_nested_struct_fields\" title=\"Methods on Anonymous nested struct fields\">Methods on Anonymous nested struct fields<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-9\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Exported_Method\" title=\"Exported Method\">Exported Method<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-10\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Method_Chaining\" title=\"Method Chaining\">Method Chaining<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-11\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Methods_on_Non-Struct_Types\" title=\"Methods on Non-Struct Types\">Methods on Non-Struct Types<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-12\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/#Conclusion\" title=\"Conclusion\">Conclusion<\/a><\/li><\/ul><\/nav><\/div>\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Overview\"><\/span><strong>Overview<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">A method in golang is nothing but a function with a receiver. A receiver is an instance of some specific type such as struct, but it can be an instance of any other custom type. So basically when you attach a function to a type, then that function becomes a method for that type. The method will have access to the properties of the receiver and can call the receiver&#8217;s other methods.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Why_Method\"><\/span><strong>Why Method<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Since method lets you define a function on a type, it lets you write object-oriented code in Golang. There are also some other benefits such as two different methods can have the same name in the same package which is not possible with functions<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Format_of_a_Method\"><\/span><strong>Format of a Method<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Below is the format for a method<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">func (receiver receiver_type) some_func_name(arguments) return_values<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">The method receiver and receiver type appear between the <strong>func<\/strong> keyword and the function name. The return_values come at the last.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Also, let&#8217;s understand more differences between a function and a method. There are some important differences between them. Below is the signature of a function<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Function:<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">func some_func_name(arguments) return_values<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">We have already seen the signature of a method<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Method:<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">func (receiver receiver_type) some_func_name(arguments) return_values<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">From the above signature, it is clear that the method has a receiver argument. This is the only difference between function and method, but due to it they differ in terms of functionality they offer<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>A function can be used as first-order objects and can be passed around while methods cannot.<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Methods can be used for chaining on the receiver while function cannot be used for the same.<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>There can exist different methods with the same name with a different receiver, but there cannot exist two different functions with the same name in the same package.<\/li><\/ul>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Methods_on_Structs\"><\/span><strong>Methods on Structs<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Golang is not an object-oriented language. It doesn&#8217;t support type inheritance, but it does allow us to define methods on any custom type including structs. Since struct is a named collection of fields and methods can also be defined on it. As such struct in golang can be compared to a class in Object-Oriented Languages.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see an example of method on struct<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n    name   string\n    age    int\n    salary int\n}\n\nfunc (e employee) details() {\n    fmt.Printf(\"Name: %s\\n\", e.name)\n    fmt.Printf(\"Age: %d\\n\", e.age)\n}\n\nfunc (e employee) getSalary() int {\n    return e.salary\n}\n\nfunc main() {\n    emp := employee{name: \"Sam\", age: 31, salary: 2000}\n    emp.details()\n    fmt.Printf(\"Salary %d\\n\", emp.getSalary())\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: Sam\nAge: 31\nSalary 2000<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Notice that the receiver is available inside the method and fields of the receiver can be accessed inside the method. <\/p>\n\n\n\n<p class=\"has-medium-font-size\">Can field of the receiver also be changed inside the method?<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see that<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n    name   string\n    age    int\n    salary int\n}\n\nfunc (e employee) setNewName(newName string) {\n    e.name = newName\n}\n\nfunc main() {\n    emp := employee{name: \"Sam\", age: 31, salary: 2000}\n    emp.setNewName(\"John\")\n    fmt.Printf(\"Name: %s\\n\", emp.name)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: Sam<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">A method setNewName is defined on the employee struct in the above code. In this method, we update the name of the employee like this<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">e.name = newName<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">After setting the new name when we print the employee name again in the main function, we see that the old name &#8220;Sam&#8221; is printed instead of &#8220;John&#8221;. This happens because method is defined on a value receiver<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">func (e employee) setNewName(newName string)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Since the method is defined on a value receiver when the method is called a copy of the receiver is made and that copy of the receiver is available inside the method. Since it is a copy, any changes made to the value receiver is not visible to the caller. That is why it prints the old name &#8220;Sam&#8221; instead of &#8220;John&#8221;. Now the question which comes to the mind whether there is any way to fix this. And the answer is yes, and this is where pointer receivers come into the picture.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Method_on_a_Pointer_Receiver\"><\/span><strong>Method on a Pointer Receiver<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">In the above example we saw a method on a value receiver. Any change made to a value receiver is not visible to the caller. Methods can also be defined on a pointer receiver. Any change made to the pointer receiver will be visible to the caller. Let&#8217;s see an example<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n    name   string\n    age    int\n    salary int\n}\n\nfunc (e *employee) setNewName(newName string) {\n    e.name = newName\n}\n\nfunc main() {\n    emp := &employee{name: \"Sam\", age: 31, salary: 2000}\n    emp.setNewName(\"John\")\n    fmt.Printf(\"Name: %s\\n\", emp.name)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: John<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">In above program, we defined the method <strong>setNewName <\/strong>on a pointer receiver<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">func (e *employee) setNewName(newName string)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Then we created an employee pointer and called the <strong>setNewName <\/strong>method<strong>&nbsp;<\/strong>on it. We see that the changes made to the employee pointer inside the <strong>setNewName <\/strong>are visible to the caller and it prints the new name.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Is it necessary to create the employee pointer to call a method with a pointer receiver? No, it is not. The method can be called on the employee instance and the language will take care of it to correctly pass it as a pointer to the method. This flexibility is provided by the language.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see an example<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n    name   string\n    age    int\n    salary int\n}\n\nfunc (e *employee) setNewName(newName string) {\n    e.name = newName\n}\n\nfunc main() {\n    emp := employee{name: \"Sam\", age: 31, salary: 2000}\n    emp.setNewName(\"John\")\n\n    fmt.Printf(\"Name: %s\\n\", emp.name)\n\n    (&emp).setNewName(\"Mike\")\n    fmt.Printf(\"Name: %s\\n\", emp.name)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: John\nName: Mike<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">We see in the above program that even if a method is defined on a pointer receiver but we are calling the method with a non-pointer employee instance<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">emp.setNewName(\"John\")<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">But the language passes the receiver as a pointer and therefore the changes are visible to the caller.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Even this way of calling is valid<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">(&emp).setNewName(\"Mike\")<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Now, how about the other way around. If a method is defined on a value receiver, can the method be called with a pointer of the receiver? <\/p>\n\n\n\n<p class=\"has-medium-font-size\">Yes, even this is valid and the language takes care of passing the argument correctly as value receiver irrespective of whether the method was called on a pointer or normal struct. <\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see an example<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n    name   string\n    age    int\n    salary int\n}\n\nfunc (e employee) setNewName(newName string) {\n    e.name = newName\n}\n\nfunc main() {\n    emp := employee{name: \"Sam\", age: 31, salary: 2000}\n    emp.setNewName(\"John\")\n\n    fmt.Printf(\"Name: %s\\n\", emp.name)\n    (&emp).setNewName(\"Mike\")\n\n    fmt.Printf(\"Name: %s\\n\", emp.name)\n    emp2 := &employee{name: \"Sam\", age: 31, salary: 2000}\n    emp2.setNewName(\"John\")\n    fmt.Printf(\"Name: %s\\n\", emp2.name)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: Sam\nName: Sam\nName: Sam<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Do note here since in all three cases, the <strong>setNewName<\/strong> method had a value receiver hence changes are not visible to the caller as the value is passed as a copy. It prints the old name in all three cases<\/p>\n\n\n\n<p class=\"has-medium-font-size\">To summarize what we learnt above<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If a method has a value receiver it supports calling of that method with both value and pointer receiver<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If a method has a pointer receiver then also it supports calling of that method with both value and pointer receiver<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">This is unlike function where if<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If a function has a pointer argument then it will only accept a pointer as an argument<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If a function has a value argument then it will only accept a value as an argument<\/li><\/ul>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"When_to_use_pointer_receiver\"><\/span><strong>When to use pointer receiver<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>When the changes to the receiver made inside the method have to be visible to the caller.<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>When the struct is big, then it is better to use a pointer receiver otherwise a copy of the struct will be made every time a method is called which will be expensive<\/li><\/ul>\n\n\n\n<p><\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Some_More_Points_to_note_about_methods\"><\/span><strong>Some More Points to note about methods<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>The receiver type has to be defined in the same package as the method definition. On defining a method on a receiver that exists in a different package, below error will be raised.<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">ERROR: cannot define new methods on non-local types<\/code><\/pre>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Till now we have seen a method invocation using a dot operator. There is one other way to call a method as well as shown in below example<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n\tname   string\n\tage    int\n\tsalary int\n}\n\nfunc (e employee) details() {\n\tfmt.Printf(\"Name: %s\\n\", e.name)\n\tfmt.Printf(\"Age: %d\\n\", e.age)\n}\n\nfunc (e *employee) setName(newName string) {\n\te.name = newName\n}\n\nfunc main() {\n\temp := employee{name: \"Sam\", age: 31, salary: 2000}\n\temployee.details(emp)\n\n\t(*employee).setName(&emp, \"John\")\n\n\tfmt.Printf(\"Name: %s\\n\", emp.name)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: Sam\nAge: 31\nName: John<\/code><\/pre>\n\n\n\n<p>In above example we see a different method for calling a method. There are two cases<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>When the method has a value receiver then it can be called as below which is struct name followed by method name. The first argument is the value receiver itself.<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">employee.details(emp)<\/code><\/pre>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>When the method has a pointer receiver then it can be called as below which is a pointer to struct name followed by method name. The first argument is the pointer receiver.<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">(*employee).setName(&emp, \"John\")<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Also note that arguments of the method starts from the second argument as for setName function above:<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">(*employee).setName(&emp, \"John\")<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">You will rarely see this style being used and the dot notation style that we discussed earlier is the recommended as well as the most common way.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Methods_on_Anonymous_nested_struct_fields\"><\/span><strong>Methods on Anonymous nested struct fields<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see a program<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n\tname   string\n\tage    int\n\tsalary int\n\taddress\n}\n\ntype address struct {\n\tcity    string\n\tcountry string\n}\n\nfunc (a address) details() {\n\tfmt.Printf(\"City: %s\\n\", a.city)\n\tfmt.Printf(\"Country: %s\\n\", a.country)\n}\n\nfunc main() {\n\taddress := address{city: \"London\", country: \"UK\"}\n\n\temp := employee{name: \"Sam\", age: 31, salary: 2000, address: address}\n\n\temp.details()\n\n\temp.address.details()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">City: London\nCountry: UK\nCity: London\nCountry: UK<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Notice in above program that details method of address struct can be accessed in two ways<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">emp.details()\nemp.address.details()<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">So in case of an anonymous nested struct, methods of that struct can be directly accessed.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Exported_Method\"><\/span><strong>Exported Method<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Go doesn\u2019t have any public,&nbsp; private or protected keyword. The only mechanism to control the visibility outside the package is using the capitalized and non-capitalized formats<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li><strong>Capitalized Identifiers<\/strong>&nbsp;are exported. The capital letter indicates that this is an exported identifier and is available outside the package.<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li><strong>Non-capitalized identifiers&nbsp;<\/strong>are not exported.&nbsp;The lowercase indicates that the identifier is not exported and will only be accessed from within the same package.<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">So any struct which starts with a capital letter is exported to other packages.&nbsp; Similarly, any struct field which starts with capital is exported otherwise not. And also similarly any struct method which starts with a capital letter is exported. Let\u2019s see an example that shows exporting and non-exporting of structs, struct fields, and methods.&nbsp; See&nbsp;<strong>model.go<\/strong>&nbsp;and <strong>test.go<\/strong> below. Both belong to the <strong>main<\/strong> package.<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Structure<ul><li>Struct&nbsp;<strong>Person<\/strong>&nbsp;is exported<\/li><li>Struct&nbsp;<strong>company<\/strong>&nbsp;is non-exported<\/li><\/ul><\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Structure\u2019s Field<ul><li><strong>Person<\/strong>&nbsp;struct field&nbsp;<strong>Name<\/strong>&nbsp;is exported<\/li><li><strong>Person<\/strong>&nbsp;struct field&nbsp;<strong>age<\/strong>&nbsp;is not exported but <strong>Name<\/strong> is exported<\/li><\/ul><\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Structure&#8217;s Method<ul><li><strong>Person<\/strong> Struct&#8217;s Method <strong>GetAge()<\/strong> is exported<\/li><li><strong>Person<\/strong> Struct&#8217;s Method <strong>getName()<\/strong> is not exported<\/li><\/ul><\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\"><strong>model.go<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\n\/\/Person struct\ntype Person struct {\n    Name string\n    age  int\n}\n\n\/\/GetAge of person\nfunc (p *Person) GetAge() int {\n    return p.age\n}\n\nfunc (p *Person) getName() string {\n    return p.Name\n}\n\ntype company struct {\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s write a file <strong>test.go<\/strong> in same <strong>main<\/strong> package. See below.<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>test.go<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\n\/\/Test function\nfunc Test() {\n    \/\/STRUCTURE IDENTIFIER\n    p := &Person{\n        Name: \"test\",\n        age:  21,\n    }\n    fmt.Println(p)\n    c := &company{}\n    fmt.Println(c)\n    \n    \/\/STRUCTURE'S FIELDS\n    fmt.Println(p.Name)\n    fmt.Println(p.age)\n\n    \n    \/\/STRUCTURE'S METHOD\n    fmt.Println(p.GetAge())\n    fmt.Println(p.getName())\n\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">On running this file, it is able to access all exported and un-exported fields in <strong>model.go<\/strong> as both lies in the same package <strong>main<\/strong>. There is no compilation error and it gives below output<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">&{test 21}\n&{}\ntest\n21\n21\ntest<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">If we move the file <strong>model.go<\/strong> to a different package named <strong>model. <\/strong>Now the output on running &#8216;go build&#8217; will give compilation errors. All the compilation errors are because <strong>test.go<\/strong> in <strong>main<\/strong> package to not able to refer to un-exported fields of <strong>model.go<\/strong> in <strong>model<\/strong> package.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">The compilation error will be<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p.getName undefined (cannot refer to unexported field or method model.(*Person).getName)<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Method_Chaining\"><\/span><strong>Method Chaining<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">For method chaining to be possible the methods in the chain should return the receiver. Returning the receiver for the last method inn the chain is optional.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see an example of method chaining.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype employee struct {\n\tname   string\n\tage    int\n\tsalary int\n}\n\nfunc (e employee) printName() employee {\n\tfmt.Printf(\"Name: %s\\n\", e.name)\n\treturn e\n}\n\nfunc (e employee) printAge() employee {\n\tfmt.Printf(\"Age: %d\\n\", e.age)\n\treturn e\n}\n\nfunc (e employee) printSalary() {\n\tfmt.Printf(\"Salary: %d\\n\", e.salary)\n}\n\nfunc main() {\n\temp := employee{name: \"Sam\", age: 31, salary: 2000}\n\temp.printName().printAge().printSalary()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Name: Sam\nAge: 31\nSalary: 2000<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Methods_on_Non-Struct_Types\"><\/span><strong>Methods on Non-Struct Types<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Methods can also be defined on a non-struct custom type. Non-struct custom types can be created through type definition. Below is the format for creating a new custom type<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type {type_name} {built_in_type}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">For example we can a named custom type <strong>myFloat<\/strong> of type <strong>float64<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type myFloat float64<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Methods can be defined on the named custom type.&nbsp;See below example:<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Code<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype myFloat float64\n\nfunc (m myFloat) ceil() float64 {\n    return math.Ceil(float64(m))\n}\n\nfunc main() {\n    num := myFloat(1.4)\n    fmt.Println(num.ceil())\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">2<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Conclusion\"><\/span><strong>Conclusion<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">This is all about using method in Go. Hope you have liked this article. Please share feedback\/mistakes\/improvements in comments<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Next Tutorial<\/strong>\u00a0\u2013\u00a0<a href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/\">Interface<\/a><br><strong>Previous Tutorial<\/strong>\u00a0\u2013 <a href=\"https:\/\/golangbyexamples.com\/maps-in-golang\">Maps<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>This is the\u00a0 chapter 20 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013\u00a0Golang Comprehensive Tutorial Series Next Tutorial\u00a0\u2013\u00a0InterfacePrevious Tutorial\u00a0\u2013 Maps Now let\u2019s check&#8230;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"spay_email":"","footnotes":"","jetpack_publicize_message":"","jetpack_is_tweetstorm":false},"categories":[1],"tags":[181,3,4],"class_list":["post-2289","post","type-post","status-publish","format-standard","hentry","category-tech","tag-complete-guide","tag-go","tag-golang"],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v22.7 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Method in Go (Golang) - Welcome To Golang By Example<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/golangbyexamples.com\/method-in-golang\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Method in Go (Golang) - Welcome To Golang By Example\" \/>\n<meta property=\"og:description\" content=\"This is the\u00a0 chapter 20 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013\u00a0Golang Comprehensive Tutorial Series Next Tutorial\u00a0\u2013\u00a0InterfacePrevious Tutorial\u00a0\u2013 Maps Now let\u2019s check...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/golangbyexamples.com\/method-in-golang\/\" \/>\n<meta property=\"og:site_name\" content=\"Welcome To Golang By Example\" \/>\n<meta property=\"article:published_time\" content=\"2020-06-20T06:08:11+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2020-11-25T19:31:37+00:00\" \/>\n<meta name=\"author\" content=\"admin\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"admin\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"12 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/golangbyexamples.com\/method-in-golang\/\",\"url\":\"https:\/\/golangbyexamples.com\/method-in-golang\/\",\"name\":\"Method in Go (Golang) - Welcome To Golang By Example\",\"isPartOf\":{\"@id\":\"https:\/\/golangbyexamples.com\/#website\"},\"datePublished\":\"2020-06-20T06:08:11+00:00\",\"dateModified\":\"2020-11-25T19:31:37+00:00\",\"author\":{\"@id\":\"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f\"},\"breadcrumb\":{\"@id\":\"https:\/\/golangbyexamples.com\/method-in-golang\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/golangbyexamples.com\/method-in-golang\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/golangbyexamples.com\/method-in-golang\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/golangbyexamples.com\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Method in Go (Golang)\"}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/golangbyexamples.com\/#website\",\"url\":\"https:\/\/golangbyexamples.com\/\",\"name\":\"Welcome To Golang By Example\",\"description\":\"\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/golangbyexamples.com\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f\",\"name\":\"admin\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/golangbyexamples.com\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g\",\"caption\":\"admin\"},\"url\":\"https:\/\/golangbyexamples.com\/author\/admin\/\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Method in Go (Golang) - Welcome To Golang By Example","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/golangbyexamples.com\/method-in-golang\/","og_locale":"en_US","og_type":"article","og_title":"Method in Go (Golang) - Welcome To Golang By Example","og_description":"This is the\u00a0 chapter 20 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013\u00a0Golang Comprehensive Tutorial Series Next Tutorial\u00a0\u2013\u00a0InterfacePrevious Tutorial\u00a0\u2013 Maps Now let\u2019s check...","og_url":"https:\/\/golangbyexamples.com\/method-in-golang\/","og_site_name":"Welcome To Golang By Example","article_published_time":"2020-06-20T06:08:11+00:00","article_modified_time":"2020-11-25T19:31:37+00:00","author":"admin","twitter_card":"summary_large_image","twitter_misc":{"Written by":"admin","Est. reading time":"12 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/golangbyexamples.com\/method-in-golang\/","url":"https:\/\/golangbyexamples.com\/method-in-golang\/","name":"Method in Go (Golang) - Welcome To Golang By Example","isPartOf":{"@id":"https:\/\/golangbyexamples.com\/#website"},"datePublished":"2020-06-20T06:08:11+00:00","dateModified":"2020-11-25T19:31:37+00:00","author":{"@id":"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f"},"breadcrumb":{"@id":"https:\/\/golangbyexamples.com\/method-in-golang\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/golangbyexamples.com\/method-in-golang\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/golangbyexamples.com\/method-in-golang\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/golangbyexamples.com\/"},{"@type":"ListItem","position":2,"name":"Method in Go (Golang)"}]},{"@type":"WebSite","@id":"https:\/\/golangbyexamples.com\/#website","url":"https:\/\/golangbyexamples.com\/","name":"Welcome To Golang By Example","description":"","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/golangbyexamples.com\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f","name":"admin","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/golangbyexamples.com\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g","caption":"admin"},"url":"https:\/\/golangbyexamples.com\/author\/admin\/"}]}},"jetpack_featured_media_url":"","jetpack_publicize_connections":[],"jetpack_sharing_enabled":true,"jetpack_shortlink":"https:\/\/wp.me\/paOs1b-AV","amp_validity":null,"amp_enabled":true,"_links":{"self":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts\/2289","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/comments?post=2289"}],"version-history":[{"count":7,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts\/2289\/revisions"}],"predecessor-version":[{"id":4557,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts\/2289\/revisions\/4557"}],"wp:attachment":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/media?parent=2289"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/categories?post=2289"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/tags?post=2289"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}