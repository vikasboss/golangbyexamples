{"id":2521,"date":"2020-07-18T13:34:43","date_gmt":"2020-07-18T08:04:43","guid":{"rendered":"https:\/\/golangbyexamples.com\/?p=2521"},"modified":"2021-08-07T11:24:36","modified_gmt":"2021-08-07T05:54:36","slug":"interface-in-golang","status":"publish","type":"post","link":"https:\/\/golangbyexamples.com\/interface-in-golang\/","title":{"rendered":"Interface in Go (Golang)"},"content":{"rendered":"\n<p><\/p>\n\n\n\n<p class=\"has-medium-font-size\">This is the&nbsp; chapter 21 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013&nbsp;<a href=\"https:\/\/golangbyexamples.com\/golang-comprehensive-tutorial\/\">Golang Comprehensive Tutorial Series<\/a><\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Next Tutorial<\/strong>&nbsp;\u2013&nbsp;<a href=\"https:\/\/golangbyexamples.com\/iota-in-golang\">Iota<\/a><br><strong>Previous Tutorial<\/strong>&nbsp;\u2013 <a href=\"https:\/\/golangbyexamples.com\/method-in-golang\/\">Method<\/a><\/p>\n\n\n\n<p class=\"has-medium-font-size\">Now let\u2019s check out the current tutorial. Below is the table of contents for current tutorial.<\/p>\n\n\n\n<div id=\"ez-toc-container\" class=\"ez-toc-v2_0_17 counter-hierarchy counter-decimal ez-toc-light-blue\">\n<div class=\"ez-toc-title-container\">\n<p class=\"ez-toc-title\">Table of Contents<\/p>\n<span class=\"ez-toc-title-toggle\"><a class=\"ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle\" style=\"display: none;\"><i class=\"ez-toc-glyphicon ez-toc-icon-toggle\"><\/i><\/a><\/span><\/div>\n<nav><ul class=\"ez-toc-list ez-toc-list-level-1\"><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-1\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Overview\" title=\"Overview\">Overview<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-2\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Implementing_an_Interface\" title=\"Implementing an Interface\">Implementing an Interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-3\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Interface_are_implemented_implicitly\" title=\"Interface are implemented implicitly\">Interface are implemented implicitly<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-4\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Interface_types_as_argument_to_a_function\" title=\"Interface types as argument to a function\">Interface types as argument to a function<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-5\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Why_Interface\" title=\"Why Interface\">Why Interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-6\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Pointer_Receiver_while_implementing_an_interface\" title=\"Pointer Receiver&nbsp; while implementing an interface\">Pointer Receiver&nbsp; while implementing an interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-7\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Non-struct_Custom_Type_Implementing_an_interface\" title=\"Non-struct Custom Type Implementing an interface\">Non-struct Custom Type Implementing an interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-8\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Type_Implementing_multiple_interfaces\" title=\"Type Implementing multiple interfaces\">Type Implementing multiple interfaces<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-9\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Zero_Value_of_Interface\" title=\"Zero Value of Interface\">Zero Value of Interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-10\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Inner_Working_of_Interface\" title=\"Inner Working of Interface\">Inner Working of Interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-11\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Embedding_Interfaces\" title=\"Embedding Interfaces\">Embedding Interfaces<\/a><ul class=\"ez-toc-list-level-2\"><li class=\"ez-toc-heading-level-2\"><a class=\"ez-toc-link ez-toc-heading-12\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Embedding_interface_in_other_interface\" title=\"Embedding interface in other interface\">Embedding interface in other interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-2\"><a class=\"ez-toc-link ez-toc-heading-13\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Embedding_interface_in_a_struct\" title=\"Embedding interface in a struct\">Embedding interface in a struct<\/a><\/li><\/ul><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-14\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Access_Underlying_Variable_of_Interface\" title=\"Access Underlying Variable of Interface\">Access Underlying Variable of Interface<\/a><ul class=\"ez-toc-list-level-2\"><li class=\"ez-toc-heading-level-2\"><a class=\"ez-toc-link ez-toc-heading-15\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Type_Assertion\" title=\"Type Assertion\">Type Assertion<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-2\"><a class=\"ez-toc-link ez-toc-heading-16\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Type_Switch\" title=\"Type Switch\">Type Switch<\/a><\/li><\/ul><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-17\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Empty_interface\" title=\"Empty interface\">Empty interface<\/a><\/li><li class=\"ez-toc-page-1 ez-toc-heading-level-1\"><a class=\"ez-toc-link ez-toc-heading-18\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/#Conclusion\" title=\"Conclusion\">Conclusion<\/a><\/li><\/ul><\/nav><\/div>\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Overview\"><\/span><strong>Overview<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Interface is a type in Go which is a collection of method signatures. These collections of method signatures are meant to represent certain behaviour. The interface declares only the method set and any type which implements all methods of the interface is of that interface type. <\/p>\n\n\n\n<p class=\"has-medium-font-size\">Interface lets you use duck typing in golang. Now, what is duck typing?<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Duck typing is a way in computer programming which lets you do duck test where we do not check type instead we check the only presence of some attributes or methods. So what really matters is whether an object has certain attributes and methods and not its type.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Duck typing comes from the below phrase<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">If it walks like a duck and quack like a duck then it must be duck<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Coming back to interface again. So what is interface? &nbsp;As mentioned before also it is a collection of method signatures. It defines the exact set of methods that a type might have. Below is the signature of an interface, it has only method signatures<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type name_of_interface interface{\n\/\/Method signature 1\n\/\/Method signature 2\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s understand the concept with the help of an example. Things will be more clear then. Let&#8217;s define an interface named <strong>animal. <\/strong>The <strong>animal<\/strong> interface has two methods <strong>breathe <\/strong>and <strong>walk<\/strong>. It defines only the method signatures and nothing else.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type animal interface {\n    breathe()\n    walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">A method signature would include<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Name of the method<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Number of arguments and type of each argument<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Number of return values and type of each return value<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">With the above declaration, we created a new interface type i.e <strong>animal. <\/strong>It is ok to define a variable of <strong>animal<\/strong> type.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s create a variable of <strong>animal<\/strong> interface type.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\nfunc main() {\n    var a animal\n    fmt.Println(a)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">nil<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">As seen in the above program it is ok to create a variable of interface type. It prints nil as the default zero value of an interface is nil.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Implementing_an_Interface\"><\/span><strong>Implementing an Interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Any type which implements the breathe and walk method then it is said to implement the <strong>animal<\/strong> interface. So if we define a <strong>lion<\/strong> struct and implements the breathe and walk method then it will implement the&nbsp;animal interface.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\ntype lion struct {\n    age int\n}\n\nfunc (l lion) breathe() {\n    fmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n    fmt.Println(\"Lion walk\")\n}\n\nfunc main() {\n    var a animal\n    a = lion{age: 10}\n    a.breathe()\n    a.walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-\">Lion breathes\nLion walk<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">We declare a variable of animal interface type<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">var a animal<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Then we assign an instance of lion struct to it.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">a = lion{}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Assigning an instance of <strong>lion<\/strong> struct to a variable of <strong>animal<\/strong> interface type works because <strong>lion<\/strong> struct implements both <strong>breathe<\/strong> and <strong>walk<\/strong> method of the animal. The type is not checked during this assignment, instead, it is enough to check that the type assigned does implement <strong>breathe<\/strong> and <strong>walk<\/strong> method.&nbsp; The concept is similar to duck typing,&nbsp; a <strong>lion<\/strong> can <strong>breathe<\/strong> and <strong>walk<\/strong> like an <strong>animal<\/strong> and hence it is an <strong>animal<\/strong>.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">If you notice that there is no explicit declaration that the lion type implements the animal interface. This brings a very important property related to interface &#8211; &#8216;Interface are implemented implicitly<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Interface_are_implemented_implicitly\"><\/span><strong>Interface are implemented implicitly<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p><\/p>\n\n\n\n<p class=\"has-medium-font-size\">There is no explicit declaration that a type implements an interface. In fact, in Go there doesn&#8217;t exist any <strong>&#8220;implements&#8221; <\/strong>keyword similar to Java.&nbsp; A type implements an interface if it implements all the methods of the interface.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">As seen above, It is correct to define a variable of an interface type and we can assign any concrete type value to this variable if the concrete type implements all the methods of the interface.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">There is no explicit declaration that says that <strong>lion<\/strong> struct implements the <strong>animal<\/strong> interface. During compilation, go notices that <strong>lion<\/strong> struct implements all methods of <strong>animal<\/strong> interface hence it is allowed. Any other type which implements all methods of the <strong>animal<\/strong> interface becomes of that interface type.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see a more complex example of another type implementing the animal interface. <\/p>\n\n\n\n<p class=\"has-medium-font-size\">If we define a <strong>dog<\/strong> struct and it implements the <strong>breathe<\/strong> and <strong>walk<\/strong> method then it will also be an animal.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\ntype lion struct {\n     age int\n}\n\nfunc (l lion) breathe() {\n    fmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n    fmt.Println(\"Lion walk\")\n}\n\ntype dog struct {\n     age int\n}\n\nfunc (l dog) breathe() {\n    fmt.Println(\"Dog breathes\")\n}\n\nfunc (l dog) walk() {\n    fmt.Println(\"Dog walk\")\n}\n\nfunc main() {\n    var a animal\n    \n    a = lion{age: 10}\n    a.breathe()\n    a.walk()\n  \n    a = dog{age: 5}\n    a.breathe()\n    a.walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Lion breathes\nLion walk\nDog breathes\nDog walk<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Both <strong>lion <\/strong>and <strong>dog <\/strong>implement the breathe and walk method hence they are of animal type and can correctly be assigned to a variable of interface type.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">The <strong>animal<\/strong> interface variable a was assigned a <strong>lion<\/strong> instance first and then the same variable was assigned a <strong>dog <\/strong>instance. So the type which interface variable refers to is dynamic.&nbsp; It dynamically holds a reference to the underlying type.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Two important points to note:<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>The interface static check is done during compile time &#8211; means that if a type doesn&#8217;t implement all the methods of an interface, then assigning the type instance to a variable of that interface type will raise an error during compile time. Eg. on deleting the walk method defined on lion struct, below error will be raised during the assignment<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">cannot use lion literal (type lion) as type animal in assignment:<\/code><\/pre>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>The correct method based on the type of instance is called at run time &#8211; means that the method of either lion or dog is called depending upon whether interface variable refers to an instance of lion or dog. If it refers to an instance of lion, then lion&#8217;s method is called and if it refers to an instance of dog, then dog&#8217;s method is called. That is also proven from the output. This is a way to achieve runtime polymorphism in Go.<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">It is also to be noted that the&nbsp;methods defined by the type,&nbsp; should match the entire signature of methods in the interface ie., it should match<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Name of the method<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Number of arguments and type of each argument<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Number of return values and type of each return value<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">Imagine that <strong>animal<\/strong> interface has another method <strong>speed<\/strong> which returns the int value of speed of the animal<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type animal interface {\n    breathe()\n    walk()\n    speed() int\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">If the <strong>lion<\/strong> struct has <strong>speed<\/strong> method as below which does not return the int value, then the <strong>lion<\/strong> struct will not implement <strong>animal<\/strong> interface<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">func (l lion) speed()<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Below compilation error will be raised on assigning the lion instance to a variable of type animal<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">cannot use lion literal (type lion) as type animal in assignment:\n        lion does not implement animal (wrong type for speed method)\n                have speed()\n                want speed() int<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">So in essence, method signatures are important while implementing an interface<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Interface_types_as_argument_to_a_function\"><\/span><strong>Interface types as argument to a function<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">A function can accept an argument of an interface type. Any type which implements that interface can be passed as that argument to that function. For example, in the below code, we have <strong>callBreathe<\/strong> and <strong>callWalk<\/strong> function which accept an argument of <strong>animal<\/strong> interface type. Both <strong>lion<\/strong> and <strong>dog<\/strong> instance can be passed to this function. We create an instance of both lion and dog type and pass it to the function. <\/p>\n\n\n\n<p class=\"has-medium-font-size\">It works similarly to the assignment we discussed above. During compilation no type is checked while calling the function,&nbsp; instead, it is enough to check that the type passed to the function does implement <strong>breathe<\/strong> and <strong>walk<\/strong> method.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype lion struct {\n     age int\n}\n\nfunc (l lion) breathe() {\n\tfmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n\tfmt.Println(\"Lion walk\")\n}\n\ntype dog struct {\n     age int\n}\n\nfunc (l dog) breathe() {\n\tfmt.Println(\"Dog breathes\")\n}\n\nfunc (l dog) walk() {\n\tfmt.Println(\"Dog walk\")\n}\n\nfunc main() {\n\tl := lion{age: 10}\n\tcallBreathe(l)\n\tcallWalk(l)\n\n\td := dog{age: 5}\n\tcallBreathe(d)\n\tcallWalk(d)\n}\n\nfunc callBreathe(a animal) {\n\ta.breathe()\n}\n\nfunc callWalk(a animal) {\n\ta.breathe()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Lion breathes\nLion walk\nDog breathes\nDog walk<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">In the above code, we have <strong>callBreathe<\/strong> and <strong>callWalk<\/strong> function which accept an argument of <strong>animal<\/strong> interface type. Both <strong>lion<\/strong> and <strong>dog<\/strong> instance can be passed to this function. We create an instance of both <strong>lion<\/strong> and <strong>dog<\/strong> type and pass it to the function. During compilation no type is checked while calling the function,&nbsp;instead, it is enough to check that the type passed to the function does implement <strong>breathe<\/strong> and <strong>walk<\/strong> method.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Why_Interface\"><\/span><strong>Why Interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Below are some benefits of using interface.<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Helps write more modular and decoupled code between different parts of codebase &#8211; It can help reduce dependency between different parts of codebase and provide loose coupling.<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">For eg imagine an application interacting with a database layer. If the application interacts with the database using the interface, then it never gets to know about what kind of database is being used in the background. You can change the type of database in the background, let&#8217;s say from arango db to mongo db without any change in the application layer as it interacts with the database layer via an interface which both arango db and mongo db implement.<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Interface can be used to achieve run time polymorphism in golang. RunTime Polymorphism means that a call is resolved at runtime. Let&#8217;s understand how interface can be used to achieve runtime polymorphism with an example<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">Different countries have different ways of calculating the tax. This can be represented by means of an interface.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type taxCalculator interface{\n    calculateTax()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Now&nbsp;different countries can have their own struct and can implement the <strong>calculateTax() <\/strong>method. The same <strong>calculateTax <\/strong>method is used in different contexts to calculate tax. When the compiler sees this call it delays which exact method to be called at run time.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype taxSystem interface {\n    calculateTax() int\n}\ntype indianTax struct {\n    taxPercentage int\n    income        int\n}\nfunc (i *indianTax) calculateTax() int {\n    tax := i.income * i.taxPercentage \/ 100\n    return tax\n}\ntype singaporeTax struct {\n    taxPercentage int\n    income        int\n}\nfunc (i *singaporeTax) calculateTax() int {\n    tax := i.income * i.taxPercentage \/ 100\n    return tax\n}\ntype usaTax struct {\n    taxPercentage int\n    income        int\n}\nfunc (i *usaTax) calculateTax() int {\n    tax := i.income * i.taxPercentage \/ 100\n    return tax\n}\nfunc main() {\n    indianTax := &indianTax{\n        taxPercentage: 30,\n        income:        1000,\n    }\n    singaporeTax := &singaporeTax{\n        taxPercentage: 10,\n        income:        2000,\n    }\n\n\n    taxSystems := []taxSystem{indianTax, singaporeTax}\n    totalTax := calculateTotalTax(taxSystems)\n\n\n    fmt.Printf(\"Total Tax is %d\\n\", totalTax)\n}\nfunc calculateTotalTax(taxSystems []taxSystem) int {\n    totalTax := 0\n    for _, t := range taxSystems {\n        totalTax += t.calculateTax() \/\/This is where runtime polymorphism happens\n    }\n    return totalTax\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output:<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Total Tax is 300<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Now below is the line where run time polymorphism happens.&nbsp;<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\"> totalTax += t.calculateTax() \/\/This is where runtime polymorphism happens<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">The correct <strong>calculateTax() <\/strong>method is called based upon weather the instance is of type <strong>singaporeTax<\/strong> struct tax or <strong>indianTax<\/strong> struct<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Pointer_Receiver_while_implementing_an_interface\"><\/span><strong>Pointer Receiver&nbsp; while implementing an interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">A<strong> <\/strong>method of a type can either have a pointer receiver or a value receiver. In the above examples, we only worked with the value receiver. It is to be noted that the pointer receiver can also be used to implement an interface. But there is a caveat here<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If a type implements all methods of an interface using value receiver, then both variable of that type as well pointer to the variable of that type can be used while assigning to that interface or while passing to a function which accepts an argument as that interface.<\/li><li>If a type implements all methods of an interface using pointer receiver, then the only pointer to the variable of that type can be used while assigning to that interface or while passing to a function that accepts an argument as that interface.<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">Example to demonstrate the first point above<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\ntype lion struct {\n    age int\n}\n\nfunc (l lion) breathe() {\n    fmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n    fmt.Println(\"Lion walk\")\n}\n\nfunc main() {\n    var a animal\n\n    a = lion{age: 10}\n    a.breathe()\n    a.walk()\n\n    a = &lion{age: 5}\n    a.breathe()\n    a.walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Lion breathes\nLion walk\nLion breathes\nLion walk<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">The <strong>lion <\/strong>structs implements the <strong>animal <\/strong>interface using value receiver. Hence it works for both variable of type <strong>lion<\/strong> as well as pointer to variable of type <strong>lion<\/strong>.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">This works<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">a = lion{age: 10}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">as well as this<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">a = &lion{age: 5}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Example to demonstrate the second point above. The <strong>lion <\/strong>structs implements the <strong>animal <\/strong>interface using pointer receiver. Hence it&nbsp; works for only for pointer to variable of type <strong>lion<\/strong>.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">So this works<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\"> a = &lion{age: 5}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">but this raises compilation error<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">a = lion{age: 10}<\/code><\/pre>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">cannot use lion literal (type lion) as type animal in assignment:\n        lion does not implement animal (breathe method has pointer receiver)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">See full working code<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype lion struct {\n\tage int\n}\n\nfunc (l *lion) breathe() {\n\tfmt.Println(\"Lion breathes\")\n}\n\nfunc (l *lion) walk() {\n\tfmt.Println(\"Lion walk\")\n}\n\nfunc main() {\n\tvar a animal\n\n\t\/\/a = lion{age: 10}\n\ta.breathe()\n\ta.walk()\n\n\ta = &lion{age: 5}\n\ta.breathe()\n\ta.walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Uncomment the line<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">a = lion{age: 10}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">and it will raise compilation error<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">cannot use lion literal (type lion) as type animal in assignment:\n        lion does not implement animal (breathe method has pointer receiver)<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Non-struct_Custom_Type_Implementing_an_interface\"><\/span><strong>Non-struct Custom Type Implementing an interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">So far we have only seen examples of struct type implementing an interface.&nbsp; It is also perfectly ok for any non-struct custom type to implement an interface. Let&#8217;s see an example<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype cat string\n\nfunc (c cat) breathe() {\n\tfmt.Println(\"Cat breathes\")\n}\n\nfunc (c cat) walk() {\n\tfmt.Println(\"Cat walk\")\n}\n\nfunc main() {\n\tvar a animal\n\n\ta = cat(\"smokey\")\n\ta.breathe()\n\ta.walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Cat breathes\nCat walk<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">The above program illustrates the concept that any custom type can also implement an interface. The <strong>cat<\/strong> is of string type and it implements the <strong>breathe<\/strong> and <strong>walk<\/strong> method hence it is correct to assign an instance of <strong>cat<\/strong> type to a variable of <strong>animal<\/strong> type.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Type_Implementing_multiple_interfaces\"><\/span><strong>Type Implementing multiple interfaces<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">A type implements an interface if it defines all methods of an interface. If that defines all methods of another interface then it implements that interface. In essence, a type can implement multiple interfaces.<\/p>\n\n\n\n<p class=\"has-medium-font-size\"> In below program, we have a mammal interface that has a feed method. The lion struct defines this method too hence it implements the mammal interface.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\ntype mammal interface {\n    feed()\n}\n\ntype lion struct {\n     age int\n}\nfunc (l lion) breathe() {\n    fmt.Println(\"Lion breathes\")\n}\nfunc (l lion) walk() {\n    fmt.Println(\"Lion walk\")\n}\nfunc (l lion) feed() {\n    fmt.Println(\"Lion feeds young\")\n}\nfunc main() {\n    var a animal\n    l := lion{}\n    a = l\n    a.breathe()\n    a.walk()\n    var m mammal\n    m = l\n    m.feed()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Lion breathes\nLion walk\nLion feeds young<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Zero_Value_of_Interface\"><\/span><strong>Zero Value of Interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Default or zero value of an interface is nil. Below program demonstrates that<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\ntype animal interface {\n    breathe()\n    walk()\n}\n\nfunc main() {\n    var a animal\n    fmt.Println(a)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">nil<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Inner_Working_of_Interface\"><\/span><strong>Inner Working of Interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">Like any other variable, an interface variable is represented by a type and value. Interface value, in turn under the hood, consists of two tuple<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Underlying Type<\/li><li>Underlying Value<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">See below diagram which illustrates what we mentioned above<\/p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img loading=\"lazy\" decoding=\"async\" width=\"351\" height=\"201\" src=\"https:\/\/i1.wp.com\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg?resize=351%2C201&#038;ssl=1\" alt=\"\" class=\"wp-image-2526\" srcset=\"https:\/\/i1.wp.com\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg?w=351&amp;ssl=1 351w, https:\/\/i1.wp.com\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg?resize=300%2C172&amp;ssl=1 300w\" sizes=\"auto, (max-width: 351px) 100vw, 351px\" data-recalc-dims=\"1\" \/><\/figure>\n\n\n\n<p class=\"has-medium-font-size\">For eg in case of lion struct implementing the animal interface would be like below<\/p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img loading=\"lazy\" decoding=\"async\" width=\"351\" height=\"201\" src=\"https:\/\/i1.wp.com\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface2.jpg?resize=351%2C201&#038;ssl=1\" alt=\"\" class=\"wp-image-2527\" srcset=\"https:\/\/i1.wp.com\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface2.jpg?w=351&amp;ssl=1 351w, https:\/\/i1.wp.com\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface2.jpg?resize=300%2C172&amp;ssl=1 300w\" sizes=\"auto, (max-width: 351px) 100vw, 351px\" data-recalc-dims=\"1\" \/><\/figure>\n\n\n\n<p class=\"has-medium-font-size\">Golang provides format identifiers to print the underlying type and underlying value represented by the interface value.<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>%T can be used to print the concrete type of the interface value<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>%v can be used to print the concrete value of the interface value.<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\ntype lion struct {\n    age int\n}\n\nfunc (l lion) breathe() {\n    fmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n    fmt.Println(\"Lion walk\")\n}\n\nfunc main() {\n    var a animal\n    a = lion{age: 10}\n    fmt.Printf(\"Underlying Type: %T\\n\", a)\n    fmt.Printf(\"Underlying Value: %v\\n\", a)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Concrete Type: main.lion\nConcrete Value: {10}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">An interface can be embedded in other interface as well as it can be embedded in a struct. Let&#8217;s look at each one by one<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Embedding_Interfaces\"><\/span><strong>Embedding Interfaces<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">An interface can be embedded in other interface as well as it can be embedded in a struct. Let&#8217;s look at each one by one<\/p>\n\n\n\n<h2 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Embedding_interface_in_other_interface\"><\/span><strong>Embedding interface in other interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h2>\n\n\n\n<p class=\"has-medium-font-size\">An interface can embed any number of interfaces in it as well as it can be embedded in any interface. All the methods of the embedded interface become part of the embedding interface. It is a way of creating a new interface by merging some small interfaces. Let&#8217;s understand it with an example<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Assume we have an interface <strong>animal<\/strong> as below<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type animal interface {\n    breathe()\n    walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s say there is another interface named <strong>human <\/strong>which embeds the <strong>animal<\/strong> interface<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type human interface {\n    animal\n    speak()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">So if any type needs to implement the <strong>human<\/strong> interface, then it has to define<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li><strong>breathe()<\/strong> and <strong>walk()<\/strong> method of animal interfaces animal is&nbsp; embedded in human<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li><strong>speak()<\/strong> method of human interface<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype human interface {\n\tanimal\n\tspeak()\n}\n\ntype employee struct {\n\tname string\n}\n\nfunc (e employee) breathe() {\n\tfmt.Println(\"Employee breathes\")\n}\n\nfunc (e employee) walk() {\n\tfmt.Println(\"Employee walk\")\n}\n\nfunc (e employee) speak() {\n\tfmt.Println(\"Employee speaks\")\n}\n\nfunc main() {\n\tvar h human\n\n\th = employee{name: \"John\"}\n\th.breathe()\n\th.walk()\n\th.speak()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Employee breathes\nEmployee walk\nEmployee speaks<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">As an other example, the ReaderWriter interface of the <strong>io<\/strong> package of golang (<a href=\"https:\/\/golang.org\/pkg\/io\/#ReadWriter\">https:\/\/golang.org\/pkg\/io\/#ReadWriter<\/a>) embeds two other interfaces<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>The reader interface&nbsp; &#8211; <a href=\"https:\/\/golang.org\/pkg\/io\/#Reader\">https:\/\/golang.org\/pkg\/io\/#Reader<\/a><\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>The writer interface&nbsp;&nbsp; &#8211; <a href=\"https:\/\/golang.org\/pkg\/io\/#Writer\">https:\/\/golang.org\/pkg\/io\/#Writer<\/a><\/li><\/ul>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type ReadWriter interface {\n    Reader\n    Writer\n}<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Embedding_interface_in_a_struct\"><\/span><strong>Embedding interface in a struct<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h2>\n\n\n\n<p class=\"has-medium-font-size\">An<strong>&nbsp;<\/strong>interface can be embedded in a struct as well.&nbsp; All the methods of the embedded interface can be called via that struct. How these methods will be called will depend upon whether the embedded interface is a named field or an unnamed\/anonymous field.&nbsp;<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If the embedded interface is a named field, then interface methods has to be called via the named interface name<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>If the embedded interface is unnamed\/anonymous field then interface methods can be referred directly or via the interface name<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s see a program illustrating above points<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n    breathe()\n    walk()\n}\n\ntype dog struct {\n    age int\n}\n\nfunc (d dog) breathe() {\n    fmt.Println(\"Dog breathes\")\n}\n\nfunc (d dog) walk() {\n    fmt.Println(\"Dog walk\")\n}\n\ntype pet1 struct {\n    a    animal\n    name string\n}\n\ntype pet2 struct {\n    animal\n    name string\n}\n\nfunc main() {\n    d := dog{age: 5}\n    p1 := pet1{name: \"Milo\", a: d}\n\n    fmt.Println(p1.name)\n    \/\/ p1.breathe()\n    \/\/ p1.walk()\n    p1.a.breathe()\n    p1.a.walk()\n\n    p2 := pet2{name: \"Oscar\", animal: d}\n    fmt.Println(p1.name)\n    p2.breathe()\n    p2.walk()\n    p1.a.breathe()\n    p1.a.walk()\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-\">Milo\nDog breathes\nDod walk\n\nOscar\nDog breathes\nDog walk\nDog breathes\nDog walk<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">We declared two struct <strong>pet1<\/strong> and <strong>pet2<\/strong>.&nbsp; <strong>pet1<\/strong> struct has named <strong>animal<\/strong> interface in it<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type pet1 struct {\n    a    animal\n    name string\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>pet2<\/strong> has unnamed\/anonymous <strong>animal<\/strong> interface embedded<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">type pet2 struct {\n    animal\n    name string\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">For an instance of <strong>pet1<\/strong> struct we call the <strong>breathe()<\/strong> and <strong>walk()<\/strong> method like this<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p1.a.breathe()\np1.a.walk()<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Directly calling these methods with raise compilation error<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p1.breathe()\np1.walk()<\/code><\/pre>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p1.breathe undefined (type pet1 has no field or method breathe)\np1.walk undefined (type pet1 has no field or method walk)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">For an instance of <strong>pet2<\/strong> struct we can call the <strong>breathe()<\/strong> and <strong>walk()<\/strong> method like directly<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p2.breathe()\np2.walk()<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">We can directly access the methods of embedded interface if the embedded interface is anonymous or unnamed.<\/p>\n\n\n\n<p class=\"has-medium-font-size\">Below is also valid and another way fo called methods of unnamed\/anonymous embedded interface<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p2.animal.breathe()\np2.animal.walk()<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Also note that while creating the instance of either the <strong>pet1<\/strong> or <strong>pet2<\/strong> struct, the embedded interface i.e <strong>animal<\/strong> is initialised with a type implementing&nbsp; it i.e <strong>dog<\/strong> .<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">p1 := pet1{name: \"Milo\", a: d}\np2 := pet2{name: \"Oscar\", animal: d}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">If we don&#8217;t initialise the embedded interface <strong>animal<\/strong>, then it will be intialised with the zero value of the interface which is nil. Calling <strong>breathe() <\/strong>and <strong>walk()<\/strong> method&nbsp; on such an instance of <strong>pet1<\/strong> or <strong>pet2<\/strong> struct will create a panic.<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Access_Underlying_Variable_of_Interface\"><\/span><strong>Access Underlying Variable of Interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">The underlying variable can be accessed in two ways<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Type Assertion<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>Type Switch<\/li><\/ul>\n\n\n\n<h2 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Type_Assertion\"><\/span><strong>Type Assertion<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h2>\n\n\n\n<p class=\"has-medium-font-size\">Type assertion provides a way to access the underlying variable inside the interface value of the interface by asserting the correct type of underlying value. Below is the syntax for that where <strong>i<\/strong> is an interface.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">val := i.({type})<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">The above statement is asserting that the type of underlying value in the interface is of type {type}. If this is true then the underlying value is assigned to <strong>val. <\/strong>If not then the above statement panics.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype lion struct {\n\tage int\n}\n\nfunc (l lion) breathe() {\n\tfmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n\tfmt.Println(\"Lion walk\")\n}\n\ntype dog struct {\n\tage int\n}\n\nfunc (d dog) breathe() {\n\tfmt.Println(\"Dog breathes\")\n}\n\nfunc (d dog) walk() {\n\tfmt.Println(\"Dog walk\")\n}\n\nfunc main() {\n\tvar a animal\n\n\ta = lion{age: 10}\n\tprint(a)\n\n}\n\nfunc print(a animal) {\n\tl := a.(lion)\n\tfmt.Printf(\"Age: %d\\n\", l.age)\n\n\t\/\/d := a.(dog)\n\t\/\/fmt.Printf(\"Age: %d\\n\", d.age)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Age: 10<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">This is how we assert the variable <strong>a<\/strong> of type <strong>animal<\/strong> to have underlying type as <strong>lion<\/strong>.<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">l := a.(lion)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Below line will create a panic as underlying type is <strong>lion<\/strong> and not <strong>dog<\/strong>. Uncomment the line to check it out<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">\/\/d := a.(dog)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Type assertion provides another way to get the underlying value and which also prevents a panic. The syntax for that is<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">val, ok := i.(<type>)<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">In this case type assertion returns two values, the first value is the same as discussed above, the other value is boolean indicating whether the type assertion was correct or not. This value is<\/p>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>true if the type assertion is correct meaning the type asserted is same as the underlying type<\/li><\/ul>\n\n\n\n<ul class=\"has-medium-font-size wp-block-list\"><li>false if the type assertion fails.<\/li><\/ul>\n\n\n\n<p class=\"has-medium-font-size\">So the second is a good way of doing type assertion since it prevents a panic. Let&#8217;s see an example<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype lion struct {\n\tage int\n}\n\nfunc (l lion) breathe() {\n\tfmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n\tfmt.Println(\"Lion walk\")\n}\n\ntype dog struct {\n\tage int\n}\n\nfunc (d dog) breathe() {\n\tfmt.Println(\"Dog breathes\")\n}\n\nfunc (d dog) walk() {\n\tfmt.Println(\"Dog walk\")\n}\n\nfunc main() {\n\tvar a animal\n\n\ta = lion{age: 10}\n\tprint(a)\n\n}\n\nfunc print(a animal) {\n\tl, ok := a.(lion)\n\tif ok {\n\t\tfmt.Println(l)\n\t} else {\n\t\tfmt.Println(\"a is not of type lion\")\n\t}\n\n\td, ok := a.(dog)\n\tif ok {\n\t\tfmt.Println(d)\n\t} else {\n\t\tfmt.Println(\"a is not of type lion\")\n\t}\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output:<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">{10}\na is not of type lion<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">Let&#8217;s move on to type switch now.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Type_Switch\"><\/span><strong>Type Switch<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h2>\n\n\n\n<p class=\"has-medium-font-size\">Type switch enables us to do above type assertion in series. See below code example for the same<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype animal interface {\n\tbreathe()\n\twalk()\n}\n\ntype lion struct {\n\tage int\n}\n\nfunc (l lion) breathe() {\n\tfmt.Println(\"Lion breathes\")\n}\n\nfunc (l lion) walk() {\n\tfmt.Println(\"Lion walk\")\n}\n\ntype dog struct {\n\tage int\n}\n\nfunc (d dog) breathe() {\n\tfmt.Println(\"Dog breathes\")\n}\n\nfunc (d dog) walk() {\n\tfmt.Println(\"Dog walk\")\n}\n\nfunc main() {\n\tvar a animal\n\n\tx = lion{age: 10}\n\tprint(x)\n\n}\n\nfunc print(a animal) {\n\tswitch v := a.(type) {\n\tcase lion:\n\t\tfmt.Println(\"Type: lion\")\n\tcase dog:\n\t\tfmt.Println(\"Type: dog\")\n\tdefault:\n\t\tfmt.Printf(\"Unknown Type %T\", v)\n\t}\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output:<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">Type: lion<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\">In the code above, using the type switch we determine the type of value contained in interface variable x is <strong>lion<\/strong> or <strong>dog<\/strong> or some other type. It is also ok to add more different types in case statement<\/p>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Empty_interface\"><\/span><strong>Empty interface<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">An empty interface has no methods , hence by default all concrete types implement the empty interface. If you write a function that accepts an empty interface then you can pass any type to that function. See working code below<\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n    test(\"thisisstring\")\n    test(\"10\")\n    test(true)\n}\n\nfunc test(a interface{}) {\n    fmt.Printf(\"(%v, %T)\\n\", a, a)\n}<\/code><\/pre>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Output<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-go\">(thisisstring, string)\n(10, string)\n(true, bool)<\/code><\/pre>\n\n\n\n<h1 class=\"wp-block-heading\"><span class=\"ez-toc-section\" id=\"Conclusion\"><\/span><strong>Conclusion<\/strong><span class=\"ez-toc-section-end\"><\/span><\/h1>\n\n\n\n<p class=\"has-medium-font-size\">This is all about interface in go. Hope you have liked this article. Please share feedback\/improvemets\/mistakes in comments.<\/p>\n\n\n\n<p class=\"has-medium-font-size\"><strong>Next Tutorial<\/strong>&nbsp;\u2013&nbsp;<a href=\"https:\/\/golangbyexamples.com\/iota-in-golang\">Iota<\/a><br><strong>Previous Tutorial<\/strong>&nbsp;\u2013 <a href=\"https:\/\/golangbyexamples.com\/method-in-golang\/\">Method<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>This is the&nbsp; chapter 21 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013&nbsp;Golang Comprehensive Tutorial Series Next Tutorial&nbsp;\u2013&nbsp;IotaPrevious Tutorial&nbsp;\u2013 Method Now let\u2019s check&#8230;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"spay_email":"","footnotes":"","jetpack_publicize_message":"","jetpack_is_tweetstorm":false},"categories":[1],"tags":[3],"class_list":["post-2521","post","type-post","status-publish","format-standard","hentry","category-tech","tag-go"],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v22.7 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Interface in Go (Golang) - Welcome To Golang By Example<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/golangbyexamples.com\/interface-in-golang\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Interface in Go (Golang) - Welcome To Golang By Example\" \/>\n<meta property=\"og:description\" content=\"This is the&nbsp; chapter 21 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013&nbsp;Golang Comprehensive Tutorial Series Next Tutorial&nbsp;\u2013&nbsp;IotaPrevious Tutorial&nbsp;\u2013 Method Now let\u2019s check...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/golangbyexamples.com\/interface-in-golang\/\" \/>\n<meta property=\"og:site_name\" content=\"Welcome To Golang By Example\" \/>\n<meta property=\"article:published_time\" content=\"2020-07-18T08:04:43+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2021-08-07T05:54:36+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg\" \/>\n<meta name=\"author\" content=\"admin\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"admin\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"19 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/\",\"url\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/\",\"name\":\"Interface in Go (Golang) - Welcome To Golang By Example\",\"isPartOf\":{\"@id\":\"https:\/\/golangbyexamples.com\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/#primaryimage\"},\"image\":{\"@id\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg\",\"datePublished\":\"2020-07-18T08:04:43+00:00\",\"dateModified\":\"2021-08-07T05:54:36+00:00\",\"author\":{\"@id\":\"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f\"},\"breadcrumb\":{\"@id\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/golangbyexamples.com\/interface-in-golang\/\"]}]},{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/#primaryimage\",\"url\":\"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg\",\"contentUrl\":\"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg\"},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/golangbyexamples.com\/interface-in-golang\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/golangbyexamples.com\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Interface in Go (Golang)\"}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/golangbyexamples.com\/#website\",\"url\":\"https:\/\/golangbyexamples.com\/\",\"name\":\"Welcome To Golang By Example\",\"description\":\"\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/golangbyexamples.com\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f\",\"name\":\"admin\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/golangbyexamples.com\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g\",\"caption\":\"admin\"},\"url\":\"https:\/\/golangbyexamples.com\/author\/admin\/\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Interface in Go (Golang) - Welcome To Golang By Example","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/golangbyexamples.com\/interface-in-golang\/","og_locale":"en_US","og_type":"article","og_title":"Interface in Go (Golang) - Welcome To Golang By Example","og_description":"This is the&nbsp; chapter 21 of the golang comprehensive tutorial series. Refer to this link for other chapters of the series \u2013&nbsp;Golang Comprehensive Tutorial Series Next Tutorial&nbsp;\u2013&nbsp;IotaPrevious Tutorial&nbsp;\u2013 Method Now let\u2019s check...","og_url":"https:\/\/golangbyexamples.com\/interface-in-golang\/","og_site_name":"Welcome To Golang By Example","article_published_time":"2020-07-18T08:04:43+00:00","article_modified_time":"2021-08-07T05:54:36+00:00","og_image":[{"url":"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg"}],"author":"admin","twitter_card":"summary_large_image","twitter_misc":{"Written by":"admin","Est. reading time":"19 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/golangbyexamples.com\/interface-in-golang\/","url":"https:\/\/golangbyexamples.com\/interface-in-golang\/","name":"Interface in Go (Golang) - Welcome To Golang By Example","isPartOf":{"@id":"https:\/\/golangbyexamples.com\/#website"},"primaryImageOfPage":{"@id":"https:\/\/golangbyexamples.com\/interface-in-golang\/#primaryimage"},"image":{"@id":"https:\/\/golangbyexamples.com\/interface-in-golang\/#primaryimage"},"thumbnailUrl":"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg","datePublished":"2020-07-18T08:04:43+00:00","dateModified":"2021-08-07T05:54:36+00:00","author":{"@id":"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f"},"breadcrumb":{"@id":"https:\/\/golangbyexamples.com\/interface-in-golang\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/golangbyexamples.com\/interface-in-golang\/"]}]},{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/golangbyexamples.com\/interface-in-golang\/#primaryimage","url":"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg","contentUrl":"https:\/\/golangbyexamples.com\/wp-content\/uploads\/2020\/07\/interface_1.jpg"},{"@type":"BreadcrumbList","@id":"https:\/\/golangbyexamples.com\/interface-in-golang\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/golangbyexamples.com\/"},{"@type":"ListItem","position":2,"name":"Interface in Go (Golang)"}]},{"@type":"WebSite","@id":"https:\/\/golangbyexamples.com\/#website","url":"https:\/\/golangbyexamples.com\/","name":"Welcome To Golang By Example","description":"","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/golangbyexamples.com\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/golangbyexamples.com\/#\/schema\/person\/8833ea7638dafd763cb1db6c0ca4576f","name":"admin","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/golangbyexamples.com\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/?s=96&d=mm&r=g","caption":"admin"},"url":"https:\/\/golangbyexamples.com\/author\/admin\/"}]}},"jetpack_featured_media_url":"","jetpack_publicize_connections":[],"jetpack_sharing_enabled":true,"jetpack_shortlink":"https:\/\/wp.me\/paOs1b-EF","amp_validity":null,"amp_enabled":true,"_links":{"self":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts\/2521","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/comments?post=2521"}],"version-history":[{"count":9,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts\/2521\/revisions"}],"predecessor-version":[{"id":6053,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/posts\/2521\/revisions\/6053"}],"wp:attachment":[{"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/media?parent=2521"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/categories?post=2521"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/golangbyexamples.com\/wp-json\/wp\/v2\/tags?post=2521"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}